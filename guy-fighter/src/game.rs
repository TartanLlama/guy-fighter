use rand::Rng;
use rustyline::DefaultEditor;
use rustyline::error::ReadlineError;
use std::cell::RefCell;
use std::collections::HashMap;
use std::ffi::OsStr;
use std::fs;
use std::path::{Path, PathBuf};
use wasmtime::component::{Component, Linker, bindgen};
use wasmtime::{Engine, Store};

use crate::names;
use crate::visualization;

// Generates bindings for the plugin world defined in the wit/guy-fighter.wit file.
bindgen!("plugin");

// Generated by the above bindgen macro
pub use tl::guy_fighter::host::TypeOfGuy;
use tl::guy_fighter::host::Host;

pub type PluginId = usize;

pub struct GameState {
    pub builtin_types_of_guy: Vec<TypeOfGuy>,
    pub invented_types_of_guy: RefCell<Vec<(PluginId, TypeOfGuy)>>,
    pub plugin_descs: HashMap<PluginId, PluginDesc>,
    pub next_plugin_id: PluginId,
}

struct PluginState<'a> {
    plugin_id: PluginId,
    game_state: &'a GameState,
}

pub struct PluginDesc {
    pub name: String,
    pub path: PathBuf,
}

fn load_plugin(
    state: &mut GameState,
    engine: &Engine,
    linker: &Linker<PluginState>,
    path: PathBuf,
) -> wasmtime::Result<()> {
    let component = Component::from_file(engine, &path)?;

    let plugin_id = state.next_plugin_id;
    state.next_plugin_id += 1;

    let plugin_name = {
        let mut store = Store::new(
            engine,
            PluginState {
                plugin_id,
                game_state: state,
            },
        );
        let plugin = Plugin::instantiate(&mut store, &component, linker)?;
        plugin.call_init(&mut store)?;
        plugin.call_get_plugin_name(&mut store)?
    };

    state.plugin_descs.insert(
        plugin_id,
        PluginDesc {
            name: plugin_name,
            path,
        },
    );

    Ok(())
}

pub fn load_plugins(state: &mut GameState, plugins_dir: &Path) -> wasmtime::Result<()> {
    let engine = Engine::default();
    let mut linker = Linker::new(&engine);
    Plugin::add_to_linker(&mut linker, |state| state)?;

    if !plugins_dir.is_dir() {
        return Err(wasmtime::Error::msg("Plugins directory does not exist"));
    }

    for entry in fs::read_dir(plugins_dir)? {
        let path = entry?.path();
        if path.is_file() && path.extension().and_then(OsStr::to_str) == Some("wasm") {
            load_plugin(state, &engine, &linker, path)?;
        }
    }
    Ok(())
}

impl GameState {
    pub fn new() -> Self {
        GameState {
            builtin_types_of_guy: vec![
                TypeOfGuy {
                    name: "Guy who's made of nails".to_string(),
                    strength: 18,
                    agility: 0,
                    charisma: 0,
                    battle_cries: vec!["Nailed it!".to_string()],
                },
                TypeOfGuy {
                    name: "Guy who's made of normal guy stuff, except his hands, which are made of nails"
                        .to_string(),
                    strength: 14,
                    agility: 6,
                    charisma: 4,
                    battle_cries: vec!["Why is life pain?".to_string()],
                },
            ],
            invented_types_of_guy: RefCell::new(vec![]),
            plugin_descs: HashMap::new(),
            next_plugin_id: 1,
        }
    }
}

impl Host for PluginState<'_> {
    fn invent_entirely_new_type_of_guy(&mut self, guy_type: TypeOfGuy) -> () {
        // We retrieve the current plugin ID from the state, which tells us which plugin invented this type of guy.
        self.game_state
            .invented_types_of_guy
            .borrow_mut()
            .push((self.plugin_id, guy_type));
    }
}

#[derive(Clone)]
pub struct Guy<'a> {
    pub name: String,
    pub guy_type: &'a TypeOfGuy,
}

impl<'a> Guy<'a> {
    fn new(name: String, guy_type: &'a TypeOfGuy) -> Self {
        Guy { name, guy_type }
    }
}

fn select_random_guy_type(state: &GameState) -> TypeOfGuy {
    let mut rng = rand::thread_rng();

    // Get total number of guy types
    let builtin_count = state.builtin_types_of_guy.len();
    let invented_count = state.invented_types_of_guy.borrow().len();
    let total_count = builtin_count + invented_count;

    // Generate a single random index for all types
    let idx = rng.gen_range(0..total_count);

    if idx < builtin_count {
        // Select from builtin types
        state.builtin_types_of_guy[idx].clone()
    } else {
        // Select from invented types
        state.invented_types_of_guy.borrow()[idx - builtin_count]
            .1
            .clone()
    }
}

fn roll_attribute_contest(attr1: u8, attr2: u8) -> (bool, u32, u32) {
    let mut rng = rand::thread_rng();

    loop {
        let roll1 = rng.gen_range(1..=DICE_SIDES) + attr1 as u32;
        let roll2 = rng.gen_range(1..=DICE_SIDES) + attr2 as u32;

        if roll1 != roll2 {
            return (roll1 > roll2, roll1, roll2);
        }
    }
}

#[derive(Debug, Clone, Copy)]
pub enum ContestType {
    Strength,
    Agility,
    Charisma,
}

const DICE_SIDES: u32 = 20;

fn fight_round(guy1: &Guy, guy2: &Guy, round: u8) -> bool {
    let mut rng = rand::thread_rng();

    // Randomly select which attribute to contest
    let contest_type = rng.gen_range(0..3);
    let (attr1, attr2, contest_type) = match contest_type {
        0 => (
            guy1.guy_type.strength,
            guy2.guy_type.strength,
            ContestType::Strength,
        ),
        1 => (
            guy1.guy_type.agility,
            guy2.guy_type.agility,
            ContestType::Agility,
        ),
        _ => (
            guy1.guy_type.charisma,
            guy2.guy_type.charisma,
            ContestType::Charisma,
        ),
    };

    let (guy1_wins, roll1, roll2) = roll_attribute_contest(attr1, attr2);
    visualization::print_fight_round(round, guy1, guy2, contest_type, attr1, attr2, roll1, roll2);
    guy1_wins
}

fn fight(state: &GameState) {
    // Generate two random fighters
    let guy_type1 = select_random_guy_type(state);
    let guy_type2 = select_random_guy_type(state);

    let guy1 = Guy::new(names::generate_name(), &guy_type1);
    let guy2 = Guy::new(names::generate_name(), &guy_type2);

    let mut guy1_wins = 0;
    let mut guy2_wins = 0;

    visualization::print_fight_introduction(&guy1, &guy2);

    for round in 1..=3 {
        if fight_round(&guy1, &guy2, round) {
            guy1_wins += 1;
        } else {
            guy2_wins += 1;
        }

        if guy1_wins == 2 {
            visualization::print_winner(&guy1.name);
            return;
        } else if guy2_wins == 2 {
            visualization::print_winner(&guy2.name);
            return;
        }
    }
}

fn main_loop(state: GameState) -> rustyline::Result<()> {
    visualization::print_header();
    visualization::print_menu();

    let mut rl = DefaultEditor::new()?;
    loop {
        match rl.readline("guy> ") {
            Ok(line) => {
                let command = line.trim().to_lowercase();
                if command.is_empty() {
                    continue; // Skip empty lines
                }
                rl.add_history_entry(&line)?;

                match command.as_str() {
                    "quit" => break,
                    "plugins" => visualization::print_plugins_table(&state),
                    "types" => visualization::print_guy_types(&state),
                    "fight" => fight(&state),
                    "help" => visualization::print_menu(),
                    _ => println!("Unknown command: {}", command),
                }
            }
            Err(ReadlineError::Interrupted) | Err(ReadlineError::Eof) => {
                break;
            }
            Err(err) => {
                eprintln!("Error reading line: {:?}", err);
            }
        }
    }
    Ok(())
}

pub fn run_game(plugins_dir: &Path) -> wasmtime::Result<()> {
    let mut state = GameState::new();
    load_plugins(&mut state, plugins_dir)?;

    if let Err(e) = main_loop(state) {
        return Err(wasmtime::Error::msg(format!("Error in main loop: {:?}", e)));
    }
    Ok(())
}
